
"""
Python Script Executor Tool for Agent Coder.

This tool allows the agent to execute generated Python scripts in a controlled manner.
It includes basic AST validation to prevent obviously unsafe operations (e.g., using `os.system`
or `subprocess` directly), though it is not a full sandbox.
"""

from __future__ import annotations

import json
import subprocess
import tempfile
import ast
import os
import sys
from typing import Optional, Type, List

from pydantic import BaseModel, Field

try:
    from crewai.tools import BaseTool  # type: ignore
except ImportError:
    class BaseTool:
        pass

class PythonScriptInput(BaseModel):
    """Schema for PythonScriptExecutorTool arguments."""
    script_code: str = Field(
        ..., description="The full Python script code to execute."
    )
    timeout: int = Field(
        15, description="Execution timeout in seconds. Default is 15s."
    )

class PythonScriptExecutorTool(BaseTool):
    """Tool to execute Python scripts generated by the Agent Coder."""
    
    name: str = "python_script_executor"
    description: str = (
        "Executes a Python script in a separate process. "
        "Returns stdout, stderr, and exit code. "
        "Enforces safety checks (no os/subprocess) and timeouts."
    )
    args_schema: Type[BaseModel] = PythonScriptInput
    
    def _validate_safety(self, code: str) -> Optional[str]:
        """Perform static analysis to reject unsafe imports and calls."""
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return f"Syntax Error: {e}"
            
        for node in ast.walk(tree):
            # Check for imports
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                for alias in node.names:
                    if alias.name in ['os', 'subprocess', 'sys', 'shutil', 'socket']:
                        return f"Safety Violation: Import of '{alias.name}' is forbidden."
            
            # Check for potentially dangerous function calls (basic heuristic)
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in ['exec', 'eval', 'compile', 'open']:
                        return f"Safety Violation: Call to '{node.func.id}' is forbidden."
                        
        return None

    def _run(self, script_code: str, timeout: int = 15) -> str:
        # 1. Safety Check
        error = self._validate_safety(script_code)
        if error:
            return json.dumps({
                "status": "blocked",
                "error": error,
                "stdout": "",
                "stderr": ""
            })
            
        # 2. Write to temp file
        fd, temp_path = tempfile.mkstemp(suffix=".py", text=True)
        try:
            with os.fdopen(fd, "w") as f:
                f.write(script_code)
                
            # 3. Execute
            # Run with the same python interpreter
            cmd = [sys.executable, temp_path]
            
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            return json.dumps({
                "status": "success" if proc.returncode == 0 else "error",
                "return_code": proc.returncode,
                "stdout": proc.stdout,
                "stderr": proc.stderr
            })
            
        except subprocess.TimeoutExpired:
            return json.dumps({
                "status": "timeout",
                "error": f"Execution exceeded {timeout}s limit.",
                "stdout": "",
                "stderr": ""
            })
        except Exception as e:
            return json.dumps({
                "status": "exception",
                "error": str(e),
                "stdout": "",
                "stderr": ""
            })
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)
