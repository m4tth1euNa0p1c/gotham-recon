"""
Python Script Executor Tool for Agent Coder and Reflection.

P0.6: This tool allows execution of generated Python scripts in a controlled manner.
It includes AST validation to prevent unsafe operations (e.g., using `os.system`
or `subprocess` directly), though it is not a full sandbox.
"""

from __future__ import annotations

import json
import subprocess
import tempfile
import ast
import os
import sys
from typing import Optional, Type, List, ClassVar, Set

from pydantic import BaseModel, Field

try:
    from crewai.tools import BaseTool  # type: ignore
except ImportError:
    class BaseTool:
        pass


class PythonScriptInput(BaseModel):
    """Schema for PythonScriptExecutorTool arguments."""
    script_code: str = Field(
        ..., description="The full Python script code to execute."
    )
    timeout: int = Field(
        30, description="Execution timeout in seconds. Default is 30s."
    )


class PythonScriptExecutorTool(BaseTool):
    """Tool to execute Python scripts generated by the Reflection Agent."""

    name: str = "python_script_executor"
    description: str = (
        "Executes a Python script in a separate process. "
        "Returns stdout, stderr, and exit code. "
        "Enforces safety checks and timeouts. "
        "Used by the Reflection Agent to run enrichment scripts."
    )
    args_schema: Type[BaseModel] = PythonScriptInput

    # P0.6: Allowed imports for enrichment scripts (annotated as ClassVar for Pydantic)
    ALLOWED_IMPORTS: ClassVar[Set[str]] = {
        'json', 'urllib', 'urllib.request', 'urllib.error', 'urllib.parse',
        're', 'socket', 'ssl', 'datetime', 'time', 'hashlib', 'base64',
        'collections', 'itertools', 'functools', 'typing', 'string',
        'math', 'statistics', 'random', 'ipaddress', 'html', 'xml',
    }

    # P0.6: Blocked dangerous calls (annotated as ClassVar for Pydantic)
    BLOCKED_CALLS: ClassVar[Set[str]] = {'exec', 'eval', 'compile', '__import__'}

    def _validate_safety(self, code: str) -> Optional[str]:
        """Perform static analysis to reject unsafe imports and calls."""
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return f"Syntax Error: {e}"

        for node in ast.walk(tree):
            # Check for imports
            if isinstance(node, ast.Import):
                for alias in node.names:
                    module_root = alias.name.split('.')[0]
                    if module_root not in self.ALLOWED_IMPORTS and alias.name not in self.ALLOWED_IMPORTS:
                        return f"Safety Violation: Import of '{alias.name}' is not allowed. Allowed: {self.ALLOWED_IMPORTS}"

            if isinstance(node, ast.ImportFrom):
                if node.module:
                    module_root = node.module.split('.')[0]
                    if module_root not in self.ALLOWED_IMPORTS and node.module not in self.ALLOWED_IMPORTS:
                        return f"Safety Violation: Import from '{node.module}' is not allowed."

            # Check for dangerous function calls
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in self.BLOCKED_CALLS:
                        return f"Safety Violation: Call to '{node.func.id}' is forbidden."

        return None

    def _run(self, script_code: str, timeout: int = 30) -> str:
        """Execute the Python script and return results as JSON."""
        # 1. Safety Check
        error = self._validate_safety(script_code)
        if error:
            return json.dumps({
                "status": "blocked",
                "error": error,
                "stdout": "",
                "stderr": ""
            })

        # 2. Write to temp file
        fd, temp_path = tempfile.mkstemp(suffix=".py", text=True)
        try:
            with os.fdopen(fd, "w") as f:
                f.write(script_code)

            # 3. Execute with the same python interpreter
            cmd = [sys.executable, temp_path]

            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            return json.dumps({
                "status": "success" if proc.returncode == 0 else "error",
                "return_code": proc.returncode,
                "stdout": proc.stdout,
                "stderr": proc.stderr
            })

        except subprocess.TimeoutExpired:
            return json.dumps({
                "status": "timeout",
                "error": f"Execution exceeded {timeout}s limit.",
                "stdout": "",
                "stderr": ""
            })
        except Exception as e:
            return json.dumps({
                "status": "exception",
                "error": str(e),
                "stdout": "",
                "stderr": ""
            })
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)
